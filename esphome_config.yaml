esphome:
  name: "esp32-fws"
  friendly_name: "ESP32-Fernwärme"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: debug

# Enable Home Assistant API
api:
  encryption:
    key: "key"

ota:
  - platform: esphome
    password: "password"

#wifi:
#  ssid: !secret wifi_ssid
#  password: !secret wifi_password

ethernet:
  type: W5500
  clk_pin: GPIO13
  mosi_pin: GPIO11
  miso_pin: GPIO12
  cs_pin: GPIO14
  interrupt_pin: GPIO10
  reset_pin: GPIO9

web_server:
  version: 3
  port: 80
  sorting_groups:
    - id: wmz
      name: "Wärmemengenzähler"
      sorting_weight: 10
    - id: fws
      name: "FWS Übergabestation"
      sorting_weight: 20
    - id: fbh
      name: "FWS Fußbodenheizung"
      sorting_weight: 21
    - id: boiler
      name: "FWS Boiler"
      sorting_weight: 22
    - id: onewire
      name: "Heizung Temperatursensoren"
      sorting_weight: 30
    - id: diagnostics
      name: "Diagnose"
      sorting_weight: 90

debug:

# ----------------------------
# UART
# ----------------------------
uart:
  - id: mbus_uart
    rx_pin: GPIO3
    tx_pin: GPIO2
    baud_rate: 2400
    data_bits: 8
    parity: EVEN
    stop_bits: 1

  - id: fws_uart
    rx_pin: GPIO44
    tx_pin: GPIO43
    baud_rate: 2400
    data_bits: 8
    parity: NONE
    stop_bits: 1
    rx_buffer_size: 512

one_wire:
  - platform: gpio
    pin: GPIO17

switch:
  - platform: restart
    name: "Restart"
    web_server:
      sorting_weight: 05
      sorting_group_id: diagnostics

time:
  - platform: homeassistant
    id: homeassistant_time

# ----------------------------
# Timer / Intervalle
# ----------------------------

interval:
  # WMZ wird alle 10s gepollt
  - interval: 10s
    then:
      - lambda: |-
          static std::vector<uint8_t> buf;

          // 1. Alle verfügbaren Bytes einlesen
          while (id(mbus_uart).available()) {
              uint8_t b;
              if (id(mbus_uart).read_byte(&b)) {
                  buf.push_back(b);
              }
          }

          // 2. Solange mindestens Telegramm-Header im Puffer
          while (buf.size() >= 6) {
              // Suche Startbyte 0x68
              if (buf[0] != 0x68) {
                  buf.erase(buf.begin());
                  continue;
              }

              uint8_t len = buf[1];
              size_t telegram_len = len + 6; // inkl. Header + CS + Endbyte

              // Noch nicht vollständig
              if (buf.size() < telegram_len) break;

              // Prüfe Endbyte
              if (buf[telegram_len - 1] != 0x16) {
                  ESP_LOGW("mbus","Ungültiges Telegramm, verwerfe Startbyte");
                  buf.erase(buf.begin());
                  continue;
              }

              // Vollständiges Telegramm extrahieren
              std::vector<uint8_t> telegram(buf.begin(), buf.begin() + telegram_len);
              buf.erase(buf.begin(), buf.begin() + telegram_len);

              uint8_t cs = 0;
              for(int i=4; i<telegram_len-2; i++) {  // 4 = Controlbyte / Adresse etc.
                  cs += telegram[i];
              }

              if(cs != telegram[telegram_len-2]) {
                  ESP_LOGW("mbus","Checksumme ungültig (berechnet 0x%02x, empfangen 0x%02x), Telegramm verworfen", cs, telegram[telegram_len-2]);
                  continue;
              }

              // --- BCD Decoder Lambda ---
              auto bcd_le = [](size_t offset, size_t len, std::vector<uint8_t> &buf) -> float {
                  float value = 0;
                  for(int j=len-1;j>=0;j--){
                      uint8_t byte = buf[offset+j];
                      value = value*100 + ((byte>>4) & 0x0F)*10 + (byte & 0x0F);
                  }
                  return value;
              };

              auto bin_le = [](size_t offset, size_t len, std::vector<uint8_t> &buf) -> float {
                  float value = 0;
                  for(int j=len-1;j>=0;j--){
                      uint8_t byte = buf[offset+j];
                      value = value*256 + byte;
                  }
                  return value;
              };

              // --- Werte aus Telegramm auslesen ---
              int j = 19;
              do {
                  uint8_t dif_candidate = telegram[j];
                  uint8_t vif_candidate = telegram[j+1];
                  uint8_t data_len = 0;
                  bool bcd_encoded = false;
                  switch (dif_candidate & 0x0f) {
                    case 0x0:
                    case 0x1:
                    case 0x2:
                    case 0x4:
                    case 0x6:
                      data_len = dif_candidate & 0x07;
                      break;
                    case 0x5:
                      data_len = 4; // float
                      break;
                    case 0xa:
                    case 0xb:
                    case 0xc:
                      data_len = dif_candidate & 0x07;
                      bcd_encoded = true;
                      break;
                  }
                  // uint8_t data_len = dif_candidate & 0x07;
                  uint8_t data_offset = j+2;
                  bool dife_present = (dif_candidate & 0x80) != 0;
                  if (dife_present) data_offset++;

                  ESP_LOGVV("wmz", "Checking at offset %d", j);

                  if (dif_candidate == 0x0c && vif_candidate == 0x06) {
                      id(wmz_zaehlerstand).publish_state(bcd_le(data_offset,data_len,telegram));
                  }
                  else if (dif_candidate == 0x0c && vif_candidate == 0x13) {
                      id(wmz_volumen).publish_state(bcd_le(data_offset,data_len,telegram)*0.001);
                  }
                  else if (dif_candidate == 0x0c && vif_candidate == 0x2b) {
                      id(wmz_leistung).publish_state(bcd_le(data_offset,data_len,telegram));
                  }
                  else if (dif_candidate == 0x0b && vif_candidate == 0x3b) {
                      id(wmz_durchfluss).publish_state(bcd_le(data_offset,data_len,telegram));
                  }
                  else if (dif_candidate == 0x0a && vif_candidate == 0x5a) {
                      id(wmz_vorlauf).publish_state(bcd_le(data_offset,data_len,telegram)*0.1);
                  }
                  else if (dif_candidate == 0x0a && vif_candidate == 0x5e) {
                      id(wmz_ruecklauf).publish_state(bcd_le(data_offset,data_len,telegram)*0.1);
                  }
                  else if (dif_candidate == 0x0a && vif_candidate == 0x62) {
                      id(wmz_spreizung).publish_state(bcd_le(data_offset,data_len,telegram)*0.1);
                  }
                  else if (dif_candidate == 0x0b && vif_candidate == 0x26) {
                      id(wmz_betriebsstunden).publish_state(bcd_le(data_offset,data_len,telegram));
                  }
                  else
                  {
                      float value = 0;
                      if (bcd_encoded)
                          value = bcd_le(data_offset,data_len,telegram);
                      else
                          value = bin_le(data_offset,data_len,telegram);

                      if (dife_present)
                        ESP_LOGD("wmz", "OFFSET: %d, DIF: %02x, DIFE: %02x, VIF: %02x, DATA (BCD): %.0f", j, dif_candidate, telegram[j+1], telegram[j+2], value);
                      else
                        ESP_LOGD("wmz", "OFFSET: %d, DIF: %02x, VIF: %02x, DATA: %.0f", j, dif_candidate, vif_candidate, value);
                  }

                  j += 2 + data_len;
                  if (dife_present) j++;

              } while (j<telegram_len-2);
          }

  # FWS wird alle 5 Minuten gepollt
  - interval: 300s
    then:
      - lambda: |-
          static const uint8_t req_data[] = { 0x50, 0x00, 0x29, 0x4a, 0x01, 0x01, 0x64, 0x41 };
          id(fws_uart).write_array(req_data, sizeof(req_data));

  # FWS: Nach neuen Daten suchen und dekodieren
  - interval: 30s
    then:
      - lambda: |-
          static std::vector<uint8_t> buf;

          // 1. Alle verfügbaren Bytes einlesen
          while (id(fws_uart).available()) {
              uint8_t b;
              if (id(fws_uart).read_byte(&b)) {
                  buf.push_back(b);
              }
          }

          // 2. Solange mindestens Telegramm-Header im Puffer
          while (buf.size() >= 6) {
              // Suche Startsequenz 41 00 29
              if ((buf[0] != 0x41) || (buf[1] != 0x00) || (buf[2] != 0x29)) {
                  buf.erase(buf.begin());
                  continue;
              }

              uint16_t payload_len = buf[4] + buf[5]*256;
              size_t telegram_len = payload_len + 8; // inkl. Header + len + CS

              // Noch nicht vollständig
              if (buf.size() < telegram_len) break;

              ESP_LOGD("fws","Received %d bytes, now checking...", telegram_len);

              // Vollständiges Telegramm extrahieren
              std::vector<uint8_t> telegram(buf.begin(), buf.begin() + telegram_len);
              buf.erase(buf.begin(), buf.begin() + telegram_len);

              uint8_t cs_l = 0;
              for(int i=0; i<telegram_len-2; i++) {
                  cs_l ^= telegram[i];
              }

              if(cs_l != telegram[telegram_len-2]) {
                  ESP_LOGW("fws","Invalid checksum_low (calc 0x%02x, rx 0x%02x), discarding", cs_l, telegram[telegram_len-2]);
                  continue;
              }

              uint8_t cs_h = cs_l ^ 0xff;
              if(cs_h != telegram[telegram_len-1]) {
                  ESP_LOGW("fws","Invalid checksum_high (calc 0x%02x, rx 0x%02x), discarding", cs_h, telegram[telegram_len-1]);
                  continue;
              }

              if (buf[3] != 0x4a) {
                  ESP_LOGW("fws","Received a telegram (0x%02x) we're not interested in, ignoring...", buf[3]);
                  continue;
              }

              // --- temp decoder Lambda ---
              auto temp_le = [](size_t offset, std::vector<uint8_t> &buf) -> float {
                  int16_t value_int = buf[offset] | buf[offset+1]<<8;
                  float value = value_int * 0.1;
                  return value;
              };

              uint16_t time = telegram[175] + telegram[176]*256;
              uint8_t wd = telegram[177];
              uint8_t dd = telegram[178];
              uint8_t mm = telegram[179];
              uint8_t yy = telegram[180];

              static const char *WeekDay[7] = {
                "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag", "Sonntag"
              };

              char timebuf[64]; 
              snprintf(timebuf, sizeof(timebuf), "%s, %02u.%02u.%02u, %02u:%02u Uhr",
                       wd>=1 && wd <=7 ? WeekDay[wd-1]: "Unbekannter Wochentag", dd, mm, yy, time / 100, time % 100);

              uint8_t boilerModus = telegram[18];
              uint8_t fbhModus = telegram[48];

              // --- Werte aus Telegramm auslesen und direkt an Home Assistant senden
              id(fws_timestamp).publish_state(timebuf);
              id(fws_aussentemperatur).publish_state(temp_le(6,telegram));
              id(fws_RL_primaer).publish_state(temp_le(8,telegram));
              id(fws_RL_primaer_max).publish_state(temp_le(16,telegram));
              id(fws_VL_sekundaer_soll).publish_state(temp_le(14,telegram));
              id(fws_VL_sekundaer).publish_state(temp_le(10,telegram));
              id(fws_RL_sekundaer).publish_state(temp_le(12,telegram));
              id(fws_FBH_VL).publish_state(temp_le(38,telegram));
              id(fws_FBH_VL_soll).publish_state(temp_le(40,telegram));
              id(fws_FBH_Modus).publish_state(fbhModus);
              id(fws_Boiler).publish_state(temp_le(136,telegram));
              id(fws_Boiler_Ladesoll).publish_state(temp_le(140,telegram));
              id(fws_Boiler_Modus).publish_state(boilerModus);
              id(fws_Zirkulation).publish_state(temp_le(144,telegram));
          }

text_sensor:
  - platform: template
    name: "FWS Letzte Daten empfangen"
    id: fws_timestamp
    web_server:
      sorting_weight: 00
      sorting_group_id: fws

  - platform: template
    name: "Current time"
    id: currentTime
    lambda: |-
      char str[17]; time_t currTime = id(homeassistant_time).now().timestamp;
      strftime(str, sizeof(str), "%d.%m.%Y %H:%M", localtime(&currTime));
      return  { str };
    web_server:
      sorting_weight: 02
      sorting_group_id: diagnostics

  - platform: uptime
    name: "Uptime"
    web_server:
      sorting_weight: 03
      sorting_group_id: diagnostics

  - platform: debug
    device:
      name: "Device Info"
      web_server:
        sorting_weight: 04
        sorting_group_id: diagnostics

sensor:
  - platform: template
    name: "WMZ Leistung"
    id: wmz_leistung
    unit_of_measurement: "W"
    state_class: measurement
    device_class: power
    accuracy_decimals: 0
    update_interval: never
    web_server:
      sorting_weight: 01
      sorting_group_id: wmz

  - platform: template
    name: "WMZ Zählerstand"
    id: wmz_zaehlerstand
    unit_of_measurement: "kWh"
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 0
    update_interval: never
    web_server:
      sorting_weight: 02
      sorting_group_id: wmz

  - platform: template
    name: "WMZ Vorlauftemperatur"
    id: wmz_vorlauf
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 03
      sorting_group_id: wmz

  - platform: template
    name: "WMZ Rücklauftemperatur"
    id: wmz_ruecklauf
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 04
      sorting_group_id: wmz

  - platform: template
    name: "WMZ Spreizung"
    id: wmz_spreizung
    unit_of_measurement: "K"
    state_class: measurement
    device_class: temperature_delta
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 05
      sorting_group_id: wmz

  - platform: template
    name: "WMZ Volumen"
    id: wmz_volumen
    device_class: volume
    state_class: total_increasing
    unit_of_measurement: "m³"
    accuracy_decimals: 3
    update_interval: never
    web_server:
      sorting_weight: 06
      sorting_group_id: wmz

  - platform: template
    name: "WMZ Durchfluss"
    id: wmz_durchfluss
    unit_of_measurement: "L/h"
    state_class: measurement
    device_class: volume_flow_rate
    accuracy_decimals: 0
    update_interval: never
    web_server:
      sorting_weight: 07
      sorting_group_id: wmz

  - platform: template
    name: "WMZ Betriebsstunden"
    id: wmz_betriebsstunden
    state_class: total_increasing
    unit_of_measurement: "h"
    device_class: duration
    accuracy_decimals: 0
    update_interval: never
    web_server:
      sorting_weight: 07
      sorting_group_id: wmz

  - platform: template
    name: "FWS Außentemperatur"
    id: fws_aussentemperatur
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 01
      sorting_group_id: fws

  - platform: template
    name: "FWS VL sekundär Soll"
    id: fws_VL_sekundaer_soll
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 02
      sorting_group_id: fws

  - platform: template
    name: "FWS VL sekundär"
    id: fws_VL_sekundaer
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 03
      sorting_group_id: fws

  - platform: template
    name: "FWS RL sekundär"
    id: fws_RL_sekundaer
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 04
      sorting_group_id: fws

  - platform: template
    name: "FWS RL primär"
    id: fws_RL_primaer
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 05
      sorting_group_id: fws

  - platform: template
    name: "FWS RL primär max"
    id: fws_RL_primaer_max
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 06
      sorting_group_id: fws

  - platform: template
    name: "FWS FBH VL Soll"
    id: fws_FBH_VL_soll
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 01
      sorting_group_id: fbh

  - platform: template
    name: "FWS FBH VL"
    id: fws_FBH_VL
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 02
      sorting_group_id: fbh

  - platform: template
    id: fws_FBH_Modus
    name: "FWS FBH Modus"
    unit_of_measurement: ""
    accuracy_decimals: 0
    update_interval: never
    web_server:
      sorting_weight: 03
      sorting_group_id: fbh

  - platform: template
    id: fws_Boiler
    name: "FWS Boiler"
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 01
      sorting_group_id: boiler

  - platform: template
    id: fws_Boiler_Ladesoll
    name: "FWS Boiler Ladesoll"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 02
      sorting_group_id: boiler

  - platform: template
    id: fws_Zirkulation
    name: "FWS Zirkulation"
    unit_of_measurement: "°C"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: never
    web_server:
      sorting_weight: 03
      sorting_group_id: boiler

  - platform: template
    id: fws_Boiler_Modus
    name: "FWS Boiler Modus"
    unit_of_measurement: ""
    accuracy_decimals: 0
    update_interval: never
    web_server:
      sorting_weight: 04
      sorting_group_id: boiler

  - platform: internal_temperature
    id: esp_internal_temperature
    name: "ESP32 Internal Temperature"
    web_server:
      sorting_weight: 01
      sorting_group_id: diagnostics

  - platform: dallas_temp
    index: 3
    name: "Heizung FBH VL"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: 60s
    web_server:
      sorting_weight: 01
      sorting_group_id: onewire

  - platform: dallas_temp
    index: 0
    name: "Heizung FBH RL"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: 60s
    web_server:
      sorting_weight: 02
      sorting_group_id: onewire

  - platform: dallas_temp
    index: 4
    name: "Heizung Boiler"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: 60s
    web_server:
      sorting_weight: 03
      sorting_group_id: onewire

  - platform: dallas_temp
    index: 2
    name: "Heizung Boiler VL"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: 60s
    web_server:
      sorting_weight: 04
      sorting_group_id: onewire

  - platform: dallas_temp
    index: 1
    name: "Heizung Boiler RL"
    state_class: measurement
    device_class: temperature
    accuracy_decimals: 1
    update_interval: 60s
    web_server:
      sorting_weight: 05
      sorting_group_id: onewire

